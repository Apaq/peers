<?xml version="1.0"?>

<book xmlns="http://docbook.org/ns/docbook"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xl="http://www.w3.org/1999/xlink"
  xsi:schemaLocation="http://docbook.org/ns/docbook docbook.xsd
                      http://www.w3.org/1999/xlink xlink.xsd">

  <info>
    <title>Peers documentation</title>
    <author>
      <personname>
        <firstname>Yohann</firstname>
        <surname>Martineau</surname>
      </personname>
    </author>
    <copyright>
      <year>2011</year>
      <holder>Yohann Martineau</holder>
    </copyright>
    <abstract>
      <para>
        This page describes how sip softphones work. Then an in-depth analysis
        of Peers source code is provided. It has been considered that the
        reader/developer must understand general considerations before peers
        source code. Some notions about voice over ip are required to
        understand source code, they are explained in first part. 
      </para>
    </abstract>
  </info>
  <chapter>
    <title>General considerations</title>
    <para>
      Let's start with simple things. First, it may seem obvious, but we have
      to answer the question: what is Peers? Peers is a lightweight java sip
      softphone, i.e. a software that enables its users to place calls on
      internet.
    </para>
    <section>
      <title>Why standards?</title>
      <para>
        When you place calls over internet, your computer is doing many things:
        capture microphone, play remote contact's voice, send and receive voice
        over the network, etc. When we look at existing solutions, we see that
        there are many ways to do this. I will not list all applications that
        can be used to place calls over internet, but let's see main solutions:
        skype, msn, gtalk, yahoo. Those solutions are all proprietary solutions,
        i.e. big companies use their own way to communicate between their client
        applications (that's what we call a protocol). The benefit of this
        solution is that they control evolutions of their protocol.
      </para>
      <para>
        Concerning microsoft, google or yahoo, we must not forget that those
        companies take the opportunity of their visibility and their marketing
        power to distribute their applications. They are not necessarily
        telecommunications experts. This does not mean that they are providing
        poor quality software, but what would you think if your car
        manufacturer was to sell you an oven or washing machines? You would
        probably (at least) hesitate. 
      </para>
      <para>
        The problem of proprietary protocol is that a yahoo client cannot make
        calls to msn or skype to gtalk, etc. Not directly. There are gateways
        to place calls from one network to another, but they are error prone
        and imply complicated translation mechanism. They do not necessarily
        give exactly the same features, etc. This is the reason why standards
        have been created. With a common specification, developers can write
        various applications that communicate between each other. Internet is
        based on standards: HTTP, HTML, etc. Those standards are the reason of
        internet success. Everyone can reach everyone, because everyone is
        using the same language. For web pages, HTTP and HTML are the standard.
        For media sessions control (voice, video, games, etc.), SIP (Session
        Initiation Protocol) is the standard. For media sending and reception,
        RTP (Realtime Transport Protocol) is the standard. And for media
        sessions description, SDP (Session Description Protocol) is the
        standard. Those standards (apart HTML) are specified by an organization
        called <link xl:href="http://www.ietf.org/">IETF</link> (Internet
        Engineering Task Force). This organization writes its specifications
        - standards - as plain text files called RFC (Request For Comments).
        They have a number and a title, but engineers often refer to their
        number... Thus SIP is specified in
        <link xl:href="http://www.ietf.org/rfc/rfc3261.txt">RFC3261</link>. 
      </para>
      <para>
        Let's take a deep breath and dive in technical details...
      </para>
      <para>
        SIP is responsible for media sessions establishement, update and
        teardown. If someone wants to talk with a friend, he or she will tell
        the software : "I want to invite Bob for an audio session". Let's call
        Alice the person who is calling Bob. When the conversation is
        terminated, Alice or Bob will tell their client application : "I'm done
        with he or she, I want to terminate the session". That's it. This is
        SIP. SIP means Session Initiation Protocol, but SIP is not only
        responsible for sessions initiation, but also updates and ending. Its
        name is not perfect, but let's deal with it. 
      </para>
      <para>
        Neither Alice nor Bob wants to make more complicated things for a
        conversation. Thus, we can see SIP as the highest level protocol for
        internet calls, the protocol that "interacts" with users. 
      </para>
      <para>
        Let's make a pause, that was the first level of our technical diving.
      </para>
      <para>
        Now that we see the aim of SIP, let's understand next steps.
      </para>
    </section>
    <section>
      <title>Media management</title>
      <para>
        Let's start with media handling.
      </para>
      <section>
        <title>First, voice capture.</title>
        <para>
          Just a glimpse of theory.
        </para>
        <section>
          <title>Sample frequency</title>
          <para>
            Voice is captured using a microphone. Voice stream is an analog
            signal (a wave). To convert this stream to a computer-usable stream,
            it has to be converted to a digital signal (stairs). This digital
            signal is then converted to bits (0, 1) that computer understands.
            How is it done? A sample is taken in this analog wave at a regular
            interval and we will consider that this sample is valid up to the
            next sample. This is not really the case, this is an approximation.
            And if we take enough samples, we can draw a curve that is very
            similar to the original wave. The interval at which we take samples
            is called the sample frequency of the sound. 
          </para>
          <figure>
            <title>Analog to digital conversion</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="analog_digital.svg" width="96mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="analog_digital.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
        <section>
          <title>Sample size</title>
          <para>
            Another parameter will play an important role in sampling: sample
            size. To convert our sample to a computer-usable data, we have to
            define bounds for the integer that will be considered as the sample
            value. This is the sample size. The more bits we use to store one
            sample, the best the sound quality. 
          </para>
        </section>
        <section>
          <title>Number of channels</title>
          <para>
            As we are diving into digital sound analysis, we should consider
            the number of sources of sound that can be mixed up and heard by
            human ears. This is the number of channels. For telephony
            applications, the number of channels is generally one: one
            microphone makes voice capture, and delivers one source of sound.
            Even if voice applications generally consider only one source of
            sound, it is important to understand this notion as many tools use
            it to manage sound. 
          </para>
        </section>
        <section>
          <title>Endianness</title>
          <para>
            When we define a data format for integers on a computer, we have to
            define entirely the way bits are converted to integer and vice
            versa. Unfortunately, everybody did not use the same conventions to
            store integers. When we convert a decimal number to binary, we
            generally write binary numbers as hexadecimal numbers:
          </para>
          <literallayout><literal>1000 (decimal) = 1111101000 (binary) = 3E8 (hexadecimal)</literal></literallayout>
          <para>
            Binary data is generally sliced in groups of 8 bits, i.e. one byte,
            eight times the value one or zero. To store one byte on a computer,
            everybody agrees: let's take the first bit (highest power of two
            within this byte) and put it first, then second, etc. But when our
            number cannot fit into eight bits, how do we do? We split our
            number in groups of eight bits:
          </para>
          <literallayout><literal>1000 (decimal) = 03 E8 (hexadecimal)</literal></literallayout>
          <para>
            Here, I added a 0 in front of 3 to fit 3 on eight bits, that's what
            we call zero-padding. Some people decided that 03 (the most
            significant byte) would come first, followed by E8, the way we
            write. And some people decided that they would store E8 first (the
            least significant byte), followed by 03. The first solution is
            called Big-Endian, and the second one is Little-Endian. 
          </para>
        </section>
        <section>
          <title>Signed/unsigned</title>
          <para>
            The last parameter that will play an important role in audio data
            format is integer boundaries. Actually, some people decided they
            needed an integer value that would vary between zero and a positive
            value. And some people decided they needed a value that would be
            positive or negative, with a sign in front of the previous absolute
            number. The problem is that we still have a multiple of eight bits
            to store our integer. The common solution is to drop the most
            significant bit (not byte) and use its empty space to store the
            sign of our integer. 
          </para>
        </section>
      </section>
      <section>
        <title>Then, audio data encoding.</title>
        <para>
          The samples we have for the moment are sometimes called raw data of
          linear PCM (Pulse Code Modulation). To find the bandwidth that's
          necessary to transfer audio data, the following formula can be
          applied:
        </para>
        <literallayout><literal>bandwidth = frequency * sample size * number of channels</literal></literallayout>
        <para>
          (signed/unsigned or endianness do not infer on
          bandwidth as they keep the same storage space) If we consider that
          16 bits samples are taken at 8 kHz with only one channel, 128000 bits
          of data must be sent during one second to keep our voice quality.
          Even if internet providers bandwidths are growing, such an upload
          bandwidth is huge and generally not available on internet. 
        </para>
        <para>
          To face this issue, smart optimisations are applied on audio data so
          that they can fit on reasonable bandwidth, available on most networks
          on internet. Those optimisations are called codecs (coder decoder).
          They rely on voice and ear physical properties to avoid naive raw
          data transfert. I will not give too much details on codecs in this
          documentation. There are many audio codecs, but the first one that is
          generally implemented by SIP clients is G711 mu-law. Please refer to
          wikipedia
          <link xl:href="http://en.wikipedia.org/wiki/G.711">article</link>
          for more information. Once optimisations are done,
          data is compressed and needs less space to transport the same voice
          stream. 
        </para>
      </section>
      <section>
        <title>Packetization</title>
        <para>
          After data encoding, audio stream is packetized. It means that slices
          of audio stream are extracted from the encoder output. But on a SIP
          network, media data cannot be sent raw, as is. It must be sent using
          RTP (Realtime Transport Protocol). RTP strives to solve realtime
          media transport issues that can occur on IP networks. Thus, it
          provides a header to include a timestamp. This timestamp gives a clue
          about when the packet must be played by the receiver. It also
          includes a sequence number that enables packets re-ordering. The fact
          is that, on SIP networks, RTP is often transported over UDP, because
          we can afford losing a few media packets and small disorder in
          packets reception. UDP is appreciated for its speed over its
          reliability, which is a big advantage in realtime environment.
          RTP is a binary protocol which transports binary data. 
        </para>
        <para>
          On the receiver side, RTP packets are parsed. RTP headers are dropped
          and media data is extracted. 
        </para>
      </section>
      <section>
        <title>Audio playback</title>
        <para>
          Once media data is extracted, still compressed, it is transmitted to
          decoder that will generate raw uncompressed data samples. Those
          playable samples are then transmitted to a player which will send
          instructions to the sound card to play voice samples correctly. 
        </para>
      </section>
    </section>
    <section>
      <title>Session control</title>
      <para>
        Let's now understand how SIP makes people reachable on a network and talking the same codec.
      </para>
      <section>
        <title>Registration</title>
        <para>
          Let's come back to Alice and Bob. Alice and Bob both use an IP
          network to reach each other. When Alice wants to call Bob, she knows
          his SIP uri (sip:bob@biloxi.com), but her computer does not know
          where Bob is, on which computer, on which IP address. Thus, Alice and
          Bob's client application registers when their computer starts or when
          they want to be reachable by SIP network to tell a central server:
          hello, I'm here, my IP address is 1.2.3.4 and the port I'm using is
          5060. Smart readers that you are know that there are NATs (Network
          Address Translation) on internet but for the moment, I will consider
          that a public IP address is used for Alice and Bob's client
          application. 
        </para>
        <para>
          As Bob's computer is registered on a central server (called
          registrar), Alice's client application (User-Agent) sends its request
          to Bob's registrar, who will then forward the request to Bob's IP
          address and port. SIP considers that there may be several
          domains/realm with a registrar for each domain (several providers).
          Another important element on SIP networks is proxy. A proxy is an
          element that receives requests from User-Agents (or other SIP nodes),
          may modify those requests, ask authentication, computes routes, and
          then, forwards those requests to other proxies, registrars or
          User-Agents. It's a sort of relay. It may filter malformed requests,
          etc. 
        </para>
      </section>
      <section>
        <title>Codec negotiation</title>
        <para>
          Now that our User-Agents (client software) are talking the same
          control protocol: SIP, they must establish a media session so that
          Alice can hear Bob and Bob can hear Alice. SIP is a flexible
          protocol. Thus, it states that User-Agents can support several codecs
          to send or receive media packets. It specifies that G711 must be
          supported at least. This is the reason why most SIP User-Agents
          implement G711 first, and then add more complicated codecs. 
        </para>
        <para>
          As several codecs can be supported, User-Agents use a common language
          to describe their codecs in their SIP messages. This is SDP (Session
          Description Protocol). When a User-Agent sends a request to create a
          media session, it includes a description of its supported codecs. And
          when a User-Agent answers a request that is willing to create a media
          session, it also includes the set of supported codecs, even if there
          is only one. This is codec negotiation. Each User-Agent takes the
          remote party's codec list and takes the first one in this list that
          matches a codec in its own codecs list. Thus both User-Agents use the
          same way to encode and decode media data for Alice and Bob's voice.
          Generally, User-Agents put their "worst" codec in last position in
          their list so that best quality codecs are preferred. 
        </para>
        <para>
          Actually, codec negotiation relies on offer/answer model for SDP.
          This model is specified in
          <link xl:href="http://www.ietf.org/rfc3264.txt">RFC3264</link>. Thus,
          the request that wants to create a new media session may be empty,
          without any offer. In this case, the User-Agent is telling: make me
          an offer, and I'll give you my supported codecs appropriately. In
          this case, the SDP offer is in SIP response (200 OK), and the SDP
          answer is in ACK. 
        </para>
      </section>
    </section>
  </chapter>
  <chapter>
    <title>Source code analysis</title>
    <para>
      The following paragraphs apply to peers since version 0.3.1.
    </para>
    <section>
      <title>Overview</title>
      <section>
        <title>Architecture</title>
        <para>
          Peers has been developed in java, an object-oriented programming
          language. Here is Peers architecture:
        </para>
        <figure>
          <title>Peers architecture</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="packages.svg" width="80mm"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="packages.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          Peers is separated in packages (gui, sip, core, etc.). It relies only
          on standard java specification API, and two java "extensions" APIs:
          javasound and swing. If you are using a standard java platform
          (openjdk or sun jdk), everything is already included in your
          environment, you need no other library. Peers has no external
          dependency. If you don't want to download sources, and import them in
          your preferred IDE, you can use the
          <link xl:href="http://peers.svn.sourceforge.net/viewvc/peers/trunk/src/net/sourceforge/peers/">web
          interface</link> to browse sources online. If you take a look
          at the source (this will now be necessary), you will see that the
          first categorization in the source code is done on protocols and very
          high level capabilities:
        </para>
        <itemizedlist>
          <listitem>
            <para>net.sourceforge.peers.gui</para>
          </listitem>
          <listitem>
            <para>net.sourceforge.peers.media</para>
          </listitem>
          <listitem>
            <para>net.sourceforge.peers.nat</para>
          </listitem>
          <listitem>
            <para>net.sourceforge.peers.sdp</para>
          </listitem>
          <listitem>
            <para>net.sourceforge.peers.sip</para>
          </listitem>
          <listitem>
            <para>net.sourceforge.peers.rtp</para>
          </listitem>
        </itemizedlist>
        <para>
          For your information, nat package is not used for the moment, it was an
          experiment about Port Restricited Cone NAT traversal. media package is
          responsible for sound encoding. SDP and SIP do not rely on any external
          library. Of course, sdp and sip packages contains SDP related sources
          and SIP stack implementation. rtp package contains peers rtp
          implementation, which is used by media package. The only complicated
          (but interesting) package is sip. Let's see what sip is made of:
        </para>
        <itemizedlist>
          <listitem>
            <para>net.sourceforge.peers.sip.core</para>
          </listitem>
          <listitem>
            <para>net.sourceforge.peers.sip.transactionuser</para>
          </listitem>
          <listitem>
            <para>net.sourceforge.peers.sip.transaction</para>
          </listitem>
          <listitem>
            <para>net.sourceforge.peers.sip.transport</para>
          </listitem>
          <listitem>
            <para>net.sourceforge.peers.sip.syntaxencoding</para>
          </listitem>
        </itemizedlist>
        <para>
          As you probably remarked, it corresponds to
          <link xl:href="http://www.ietf.org/rfc/rfc3261.txt">RFC3261</link> layers: 
        </para>
        <figure>
          <title>SIP stack</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="sip_stack.svg" width="50mm"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="sip_stack.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          The reader will probably need to keep an eye on RFC3261 to fully
          understand the following paragraphs. I did not reinvent the wheel. The
          sip package has been implemented with simplicity and extensibility in
          mind. This implementation should not be obscure to a java developer
          that already knows SIP. The following paragraphs will contain
          <link xl:href="http://en.wikipedia.org/wiki/Unified_Modeling_Language">UML</link>
          diagrams. But before we explain the meaning of each package, let's see
          some common techniques that have been used in several packages. 
        </para>
      </section>
      <section>
        <title>State machines</title>
        <para>
          SIP defines several state machines, a
          <link xl:href="http://sourcemaking.com/design_patterns/state">design
          pattern</link> has been used for state machines. It consists of one
          class for the object that handles its state, one mother class for all
          states of this state machine and one class for each state. As there
          were several state machines, and as it was useful to log state
          transitions, a generic abstract state class has been defined, it just
          prints the old state, the new state and the transition employed. Then
          each mother state class in state machines extends this abstract state
          class: 
        </para>
        <figure>
          <title>Abstract state for all state machines</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="state-machines.svg" width="150mm"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="state-machines.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          We won't detail the role of each state machine now, just keep in mind
          the way they are managed and implemented, not what they are done for. 
        </para>
      </section>
      <section>
        <title>Managers</title>
        <para>
          The second design pattern that has been used in Peers is Factory. It
          has been used in several packages. Actually, in Peers, factories are
          called managers. Managers are more than factories, because they are
          employed to create object instances, but they are also used to store
          all references to those objects. For example, TransactionManager
          implements a method to create a new client transaction:
          createClientTransaction, and a method to retrieve a client
          transaction: getClientTransaction. Thus, when an external object
          needs to access one of the objects created by a manager, it uses its
          get method. In some cases, one manager can create several types of
          objects. In the previous example, TransactionManager manages client
          transactions and server transactions. In such cases, the appropriated
          get method must be employed. All managers have been implemented the
          same way. They contain hashtables for the object tables they manage.
          For those reasons, and as they are used to delete references to those
          objects, the word manager has been preferred to factory. 
        </para>
      </section>
      <section>
        <title>Package users</title>
        <para>
          Interaction between packages is sometimes made using interfaces and
          javabeans event pattern. Those interfaces defines objects users. Thus
          when an object outside a package needs to get information from one
          object, it implements its corresponding User interface. And then it
          gets notified about events. Users interfaces are quite similar to
          Listeners. But they are not called Listeners because they do not
          necessarily apply to pure beans or POJOs (plain old java objects). 
        </para>
        <para>
          In SIP theory, only one layer relies on two other layers: transaction
          user on transaction and transport layers. In peers implementation,
          you can find dependencies on several packages: syntaxencoding for
          message access, media for sound management, etc. This does not break
          this model. Most of those accesses are done to retrieve data from
          other objects, not to perform an action on an event. 
        </para>
      </section>
    </section>
    <section>
      <title>Package details</title>
      <section>
        <title>SIP</title>
        <para>
          Let's start with sip-related packages. The best way to get in touch
          with SIP is probably using wireshark network analyzer and its sip
          filter, and trying to place calls. We have already seen that Peers
          source code is separated in packages that correspond to SIP layers.
          We will start with the lowest layer (syntax/encoding) with simple
          message examples. Then we will climb up the layer stack. The next
          step is transport management, i.e. the way messages travel over the
          network. Next, we will see how those messages are grouped to form
          transactions. Then, we will explain how those transactions are
          grouped to manage dialogs. And last but not least, we will
          understand how dialogs are managed by core layer. But before we
          explain how those high-level layers are translated in java, let's
          discover SIP by its messages. 
        </para>
        <section>
          <title>Message anatomy</title>
          <para>
            SIP uses two types of messages: requests and responses. Requests
            contain a method (<emphasis>INVITE</emphasis> in the following
            example) that will give request aim and a request-uri
            (<emphasis>sip:bob@biloxi.example.com</emphasis>) for the
            person/server we want to reach. And responses contain a status
            code (an integer, <emphasis>200</emphasis> in next example) that
            gives response status: success, failure, etc. Each SIP message is
            made of several headers and one body. A header has a name, and
            generally one value. But it may contain several values. A SIP
            header can contain one or several parameters with the following
            syntax:
          </para>
          <literallayout><literal>header_name: header_value;param=param_value</literal></literallayout>
          <para>
            Here is an example message quoting
            <link xl:href="http://www.ietf.org/rfc/rfc3665.txt">RFC3665</link>,
            which gives simple call-flow examples.
          </para>
          <literallayout><literal>INVITE sip:bob@biloxi.example.com SIP/2.0
Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9
Max-Forwards: 70
From: Alice &lt;sip:alice@atlanta.example.com&gt;;tag=9fxced76sl
To: Bob &lt;sip:bob@biloxi.example.com&gt;
Call-ID: 3848276298220188511@atlanta.example.com
CSeq: 1 INVITE
Contact: &lt;sip:alice@client.atlanta.example.com;transport=tcp&gt;
Content-Type: application/sdp
Content-Length: 151

v=0
o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com
s=-
c=IN IP4 192.0.2.101
t=0 0
m=audio 49172 RTP/AVP 0
a=rtpmap:0 PCMU/8000</literal></literallayout>
          <para>
            This message is a request. Here is an example response. Here
            message bodies are plain text. Generally, SIP message body is
            either empty, either text. But RFC3261 states that body can
            contain any type of data, even binary data.
          </para>
          <literallayout><literal>SIP/2.0 200 OK
Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9
;received=192.0.2.101
From: Alice &lt;sip:alice@atlanta.example.com&gt;;tag=9fxced76sl
To: Bob &lt;sip:bob@biloxi.example.com&gt;;tag=8321234356
Call-ID: 3848276298220188511@atlanta.example.com
CSeq: 1 INVITE
Contact: &lt;sip:bob@client.biloxi.example.com;transport=tcp&gt;
Content-Type: application/sdp
Content-Length: 147

v=0
o=bob 2890844527 2890844527 IN IP4 client.biloxi.example.com
s=-
c=IN IP4 192.0.2.201
t=0 0
m=audio 3456 RTP/AVP 0
a=rtpmap:0 PCMU/8000</literal></literallayout>
          <para>
            Thus, here is how those messages have been separated in objects
            to ease message content access in Peers. 
          </para>
          <figure>
            <title>SIP message and its components</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="sip_syntax_encoding.svg" width="135mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="sip_syntax_encoding.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            For the moment, don't bother with body content, this is SDP
            (starting with v=0...). We will explain this syntax later. Just
            remember that this is not SIP but SDP, and thus, it's specified
            in another RFC. 
          </para>
        </section>
        <section>
          <title>Transport</title>
          <para>
            Now that we have seen SIP message bones, let's see how those
            messages are transported over the network.
          </para>
          <para>
            Transport package is quite simple: TransportManager creates
            client transports and server transports. Those client transports
            and server transports are called message senders and message
            receivers. Actually, behind the stage, DatagramSockets are doing
            the real job. It must be noted that TCP transport is not
            supported in Peers. Most User-Agents first support UDP, and then
            TCP. Peers does not break the rules. That's why TCP does not
            appear on the following class diagram. The transport layer is
            also generally responsible for message retransmissions. As SIP
            works over UDP, those message retransmissions are very important
            to avoid losing messages. 
          </para>
          <figure>
            <title>SIP transport management</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="sip_transport.svg" width="100mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="sip_transport.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            To help NAT traversal, each message sender sends "empty" SIP
            packets at scheduled interval. Actually, those packets contain
            four bytes: 0x0d 0x0a 0x0d 0x0a. Those bytes correspond to a
            couple of carriage return / line feed ("\r\n" in java).
            Furthermore, on packet reception, if the first line of this
            packet does not contain "SIP/2.0", this packet is considered as a
            keep-alive / ping packet. Thus, a pong is sent, i.e. the same
            packet is sent back to the source of the previous packet. Sent
            and received at fixed rate, those packets prevent NATs from
            closing binding sessions between local and remote sip stacks. 
          </para>
          <figure>
            <title>Sending and receiving keep-alive packets</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="ping-pong.svg" width="77mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="ping-pong.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            For datagram sockets indexing (in transport manager hashtable),
            it must be noted that keys are not strings nor integers, but
            SipTransportConnection objects. Those objects contain local
            address, remote address, local port, remote port and transport
            protocol used to convey packets. Thus when it's necessary to
            communicate with the same machine on the same port and using the
            same transport protocol, the same object is employed. 
          </para>
          <para>
            Thread management is not the same for message sending and message
            reception. MessageReceiver implements Runnable, thus it must be
            started in its own Thread. It has been considered that was
            necessary to perform message reception in one Thread, as it can
            occur at any time. But message sending is not done in its own
            Thread. It's done in caller's Thread. 
          </para>
          <para>
            Transport management has been done in a very naive way. In
            theory, UDP packets may contain several SIP messages, but this
            feature is not implemented in Peers. Actually on client side,
            this would probably be very odd to receive several SIP messages
            in the same UDP packet. In day-to-day life, it never occurs.
            Several multi-SIP messages UDP packets generally only occur
            between high-loaded servers, not on User-Agents. In theory, in
            SIP messages bigger than MTU or 1300 bytes if <link
            xl:href="http://en.wikipedia.org/wiki/Maximum_transmission_unit">MTU</link>
            is unknown are supposed to be sent on a reliable transport
            protocol such as TCP. In peers, this feature is not implemented,
            all packets are sent over UDP. 
          </para>
          <para>
            We won't explain all SIP routing philosophy, but remember that
            requests are routed using Route header if it's present, and
            request-uri domain name or IP address if Route header is not in
            message. Responses are routed using Via header. It generally
            contains an IP address and a port on which the response must be
            sent. 
          </para>
        </section>
        <section>
          <title>Transaction</title>
          <para>
            Those of you who are familiar with databases probably already
            know transactions. We could also compare SIP transactions with
            financial transactions. In each case, transaction aim is the
            same: do something if everything goes well, else do nothing. It's
            exactly the same with SIP. If any error occurs during transaction
            management, abort modifications on transaction-related objects
            (generally dialog state, etc.) and come back to the original
            state, before transaction management. Actually, this is quite
            dumb to start Peers transaction implementation description with
            transaction-fallback mechanism because no "failover" technique
            has been implemented in Peers... but at least, you are aware of
            it. 
          </para>
          <para>
            In SIP, a transaction is made of:
          </para>
          <itemizedlist>
            <listitem>
              <para>exactly one request,</para>
            </listitem>
            <listitem>
              <para>
                eventually one or several provisional response(s) (status
                code between 101 and 199),
              </para>
            </listitem>
            <listitem>
              <para>
                exactly one final response (status code between 200 and 699).
              </para>
            </listitem>
          </itemizedlist>
          <para>
            We forget forking, it's intended. Fork is not implemented in
            Peers.
          </para>
          <para>
            Transaction layer is probably the most complicated layer in SIP
            specification. There are several transaction families. To find
            transaction family, you have to answer the two following
            questions:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                Did this transaction receive or sent the request on the
                network?
              </para>
            </listitem>
            <listitem>
              <para>this transaction create a Dialog?</para>
            </listitem>
          </itemizedlist>
          <para>
            Both questions have two exclusive answers. Transactions that
            receive requests are called server transactions and transactions
            which send requests are called client transactions. Transactions
            that create a dialog are called invite transactions, as INVITE is
            the only method that can create dialogs in RFC3261. And
            transactions that will not create a dialog are called non-invite
            transactions. Thus there are four transaction types:
          </para>
          <itemizedlist>
            <listitem>
              <para>invite client transaction,</para>
            </listitem>
            <listitem>
              <para>invite server transaction,</para>
            </listitem>
            <listitem>
              <para>non-invite client transaction,</para>
            </listitem>
            <listitem>
              <para>non-invite server transaction.</para>
            </listitem>
          </itemizedlist>
          <para>
            Transactions are uniquely identified using branch parameter in
            header Via (<emphasis>z9hG4bK74bf9</emphasis> in the following
            example) and method name (<emphasis>INVITE</emphasis>). As
            requests and responses belong to a transaction, those parameters
            are present in both request and response. They are in bold font
            in the following example, which is just an extract from the
            previous messages:
          </para>
          <literallayout><literal>INVITE sip:bob@biloxi.example.com SIP/2.0
Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9
Max-Forwards: 70
[...]
SIP/2.0 200 OK
Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9
;received=192.0.2.101
From: Alice &lt;sip:alice@atlanta.example.com&gt;;tag=9fxced76sl
To: Bob &lt;sip:bob@biloxi.example.com&gt;;tag=8321234356
Call-ID: 3848276298220188511@atlanta.example.com
CSeq: 1 INVITE
Contact: &lt;sip:bob@client.biloxi.example.com;transport=tcp&gt;
[...]</literal></literallayout>
          <para>
            Server and client aspects of transaction have been implemented as
            interfaces in Peers, and invite and non-invite property have been
            implemented in abstract classes. Thus those four transactions
            have been implemented in their own class in Peers, extending and
            implementing the appropriate class and interface, as shown in the
            following diagram: 
          </para>
          <figure>
            <title>SIP transactions class diagram</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="sip_transaction.svg" width="170mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="sip_transaction.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            This class diagram also shows which classes are using transport
            layer using their corresponding SipXxxTransportUser interface. 
          </para>
          <para>
            What makes transaction package particularly verbose in Peers is
            that each transaction type has its own state machine, thus its
            corresponding mother state class and its corresponding classes
            for each state. Those state machines are provided in RFC3261 but
            here is how they have been implemented in Peers: 
          </para>
          <figure>
            <title>Invite client transaction state machine</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="invite_client_transaction.svg" width="160mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="invite_client_transaction.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Invite server transaction state machine</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="invite_server_transaction.svg" width="120mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="invite_server_transaction.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Non-invite client transaction state machine</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="non_invite_client_transaction.svg" width="140mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="non_invite_client_transaction.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Non-invite server transaction state machine</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="non_invite_server_transaction.svg" width="130mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="non_invite_server_transaction.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            Well, now that we know our transactions behavior, let's see their
            manager. Transaction manager works with transactions using their
            client/server property. Thus it uses ClientTransaction and
            ServerTransaction interfaces to handle them. 
          </para>
          <figure>
            <title>Transaction manager</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="sip_transaction_manager.svg" width="90mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="sip_transaction_manager.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
        <section>
          <title>Dialog</title>
          <para>
            Actually, in SIP specification there's a sort of confusion
            between transaction user and dialog layer. Several layers are
            using transaction layer on the upper side: core and dialog. Core
            is either User-Agent, Proxy, Registrar or Redirect Server; and
            dialog is transaction user. 
          </para>
          <para>
            Transaction user is probably the most simple layer in SIP. It
            contains Dialogs. A dialog is the representation of a media
            session on the control side. Remember there are two sides in SIP:
            media and control. Dialog is on control side, and media session
            is on media side. Media session is often the term employed in SDP
            and RTP. One state machine is necessary for dialogs. Please refer
            to RFC3261 for information about what must be inside a dialog.
            Bird view: local and remote contact addresses, unique id, etc.
            It's not a surprise, dialogs are managed using DialogManager. 
          </para>
          <figure>
            <title>Dialog state machine</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="dialog.svg" width="120mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="dialog.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            Actually, Dialog is not really a group of transactions, but a
            transaction can occur within a dialog or not. The parameter that
            will determine if a transaction is performed within a dialog is
            its Call-ID header. To be exhaustive, a dialog is identified by
            its Call-ID, tag parameter in From header and tag parameter in To
            header. This is what you will see in peers.log. Thus a
            transaction which is performed within a dialog must use the same
            Call-ID, the same local-tag and the same remote-tag. Local-tag
            and remote-tag are To-tag and From-tag but may be inverted if the
            request is coming from the UAS (User-Agent Server), i.e. the one
            who received the call. Here is an illustration of dialog
            identifier components in request and response:
          </para>
          <literallayout><literal>INVITE sip:bob@biloxi.example.com SIP/2.0
Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9
Max-Forwards: 70
From: Alice &lt;sip:alice@atlanta.example.com&gt;;tag=9fxced76sl
To: Bob &lt;sip:bob@biloxi.example.com&gt;
Call-ID: 3848276298220188511@atlanta.example.com
[...]
SIP/2.0 200 OK
Via: SIP/2.0/TCP client.atlanta.example.com:5060;branch=z9hG4bK74bf9
;received=192.0.2.101
From: Alice &lt;sip:alice@atlanta.example.com&gt;;tag=9fxced76sl
To: Bob &lt;sip:bob@biloxi.example.com&gt;;tag=8321234356
Call-ID: 3848276298220188511@atlanta.example.com
[...]</literal></literallayout>
          <para>
            In this example, the request does not contain a tag parameter in
            header To. Actually, at this time, the dialog does not exist yet. 
          </para>
        </section>
        <section>
          <title>User-Agent</title>
          <para>
            On the top of transaction user layer, we find core layer. Core
            layer defines the SIP element role. On a SIP network, we've
            already seen that there were serveral nodes:
          </para>
          <itemizedlist>
            <listitem>
              <para>proxy,</para>
            </listitem>
            <listitem>
              <para>registrar,</para>
            </listitem>
            <listitem>
              <para>redirect server,</para>
            </listitem>
            <listitem>
              <para>user-agent.</para>
            </listitem>
          </itemizedlist>
          <para>
            Peers is a user-agent. It's the software employed by users to
            place or receive calls. Actually, a user-agent is just the SIP
            part of this software. User-agent can be considered as the image
            of the software in SIP stack. This is the reason why the
            corresponding package name is:
            net.sourceforge.peers.sip.core.useragent. Peers SIP core layer,
            or core role is User-Agent. 
          </para>
          <para>
            In SIP, the core layer is the brain. Depending on its role, it
            can be more or less sophisticated, but it's the place where
            general behavior is defined. Another property of SIP protocol is
            that complex things are managed in client software applications.
            Sometimes we hear that complexity is implemented on the edge of
            the network in SIP protocol. To support this complexity, each
            single feature has been implemented in a separate class in Peers.
            There are two types of classes in core layer: request managers
            and handlers. Handlers implement method-specific code. In basic
            SIP specification, there are several methods: INVITE, BYE,
            CANCEL, ACK, OPTIONS and REGISTER. Thus, each method has its own
            handler. All methods are not dialog-related methods, those
            methods are implemented in classes that inherit MethodHandler
            directly. Dialog related methods classes have a common abstract
            class called DialogMethodHandler. This class is reponsible for
            dialog construction and updates, calling the appropriate methods
            in dialog package. The following class diagram shows those
            classes: 
          </para>
          <figure>
            <title>Method handlers</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="sip_core_method_handlers.svg" width="160mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="sip_core_method_handlers.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            Method names are generally quite explicit: INVITE is there to
            create dialogs, CANCEL cancels dialogs in progress and BYE
            terminates dialogs. But INVITE can also be used to update codec,
            the IP address and port on which RTP packets can be sent. In this
            case, they are called re-INVITEs, but the actual method that is
            present in requests is INVITE. The trick to find if an INVITE is
            an initial INVITE or a subsequent INVITE (re-INVITE) is to look
            at To header tag parameter. If this parameter is defined, a
            dialog has already been created and thus, the INVITE request is
            within this dialog. REGISTER is used to register user-agent IP
            address and port, so that it can receive SIP calls. And OPTIONS
            is used to get information about what is supported in user-agent,
            proxy, etc. Well, I did not mention ACK for the moment... ACK is
            a very particular method. It does not generate any response. It's
            just employed to acknowledge the creation of a dialog on the
            client side. Thus the server side is notified of dialog creation. 
          </para>
          <para>
            A user-agent always contains both a user-agent client and a
            user-agent server. A user-agent client is responsible for
            requests sending and a user-agent server is responsible for
            incoming requests processing. In Peers, they are called UAC and
            UAS. Sorry, I must insist on one thing. The most important aspect
            of a request is whether this request occurs inside a dialog
            (subsequent request) or outside any dialog (initial request).
            This is really important because the processing in user-agent is
            totally different. In one case, you may have to create a dialog,
            in the other you may have to update this dialog. Some processing
            is the same for all methods for initial requests and some
            processing is the same for all subsequent requests. Request
            creation is the typical example. All methods share some
            processing in creation process. Thus, in Peers,
            InitialRequestManager is responsible for initial requests
            specific handling and MidDialogRequestManager is responsible for
            subsequent requests specific handling. 
          </para>
          <figure>
            <title>Request managers</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="sip_core_request_managers.svg" width="150mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="sip_core_request_managers.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            The RequestManager is the class that keeps a reference to all
            Handlers. Even if it's an abstract class, it provides references
            to each method handler in its subclasses: InitialRequestManager
            and MidDialogRequestManager. Instances of those classes are
            references in UAC and UAS. May Peers act as user-agent server or
            user-agent client, it has to support intial requests sending,
            subsequent requests sending, initial requests reception and
            subsequent requests reception. 
          </para>
          <para>
            Let's come to our main class: UserAgent. UserAgent keeps
            references to many important objects: UAC, UAS, media related
            objects (CaptureRtpSender and IncomingRtpReader), and managers
            (ChallengeManager, DialogManager, TransactionManager and
            TransportManager). Each layer manager is referenced here. 
          </para>
          <figure>
            <title>User-Agent</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="sip_core_user_layer.svg" width="130mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="sip_core_user_layer.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            All core Handlers and Managers are instanciated within UserAgent
            constructor. Thus, when you instantiate a new UserAgent, you
            implicitly create its underlying layers objects. This is the
            reason why it's really easy to use Peers in external
            applications.
          </para>
        </section>
        <section>
          <title>Challenge management</title>
          <para>
            There's another important manager, it's ChallengeManager. In a
            SIP network, each element that receives a request can reject that
            request, asking the sender a common secret, this is a Challenge.
            ChallengeManager is responsible for Challenge management.
            Challenges are specified in <link
            xl:href="http://www.ietf.org/rfc/rfc2617.txt">RFC2617</link>.
            They provide a sort of authentication in SIP. Only two methods
            support challenges in peers: INVITE and REGISTER. And the only
            two response status codes supported by peers are 401 and 407. All
            combinations of supported methods and response codes share the
            same behavior for authentication. Thus this class handles them.
            This RFC defines a framework for HTTP authentication, but the
            same authentication framework is applied to SIP. Amongst the
            amount of authentication schemes specified for SIP, MD5 is the
            only authentication scheme supported in peers. AKA and other
            authentication schemes are not supported. Inspite those
            limitations, peers is able to authenticate on most standard SIP
            servers. 
          </para>
          <figure>
            <title>Registration example</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="registration.svg" width="50mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="registration.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
        <section>
          <title>Communication with user interface</title>
          <para>
            Communication between core SIP layer (user-agent) and graphical
            user interface is done using an interface called SipListener.
            Thus, separation between SIP layers and user interface is clearly
            identified. The communication is done with gui package, but this
            graphical user interface could be replaced with another gui, a
            web interface, or even a console interface thanks to this
            generic way of communicating between sip core layer and upper
            layer. 
          </para>
          <figure>
            <title>Interaction between core and gui</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="core-gui.svg" width="80mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="core-gui.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            A software which needs to use peers SIP stack with another gui
            can instanciate a UserAgent object and then use this user agent
            instance to communicate with peers SIP stack. The SipListener
            interface offers the user interface a way to be notified of SIP
            incoming events: incoming call, callee pickup, remote hangup,
            etc. and user actions are provided to sip core through UAC and
            UAS via UserAgent.getUAC() and UserAgent.getUAS() methods:
            invite(...), register(...), acceptCall(...) and rejectCall(...).
            Incoming events correspond to methods in SipListener interface.
            This interface is implemented by a main class in upper layer
            (EventManager in gui package), the upper layer processes the
            incoming events and eventually takes action on SIP core layer
            depending on previous events and user actions. 
          </para>
        </section>
      </section>
      <section>
        <title>SDP</title>
        <para>
          SDP package is responsible for codec negotiation. SDP itself is the
          way media sessions are described, it's specified in <link
          xl:href="http://www.ietf.org/rfc/rfc4566.txt">RFC4566</link>. This
          codec negotiation is specified in <link
          xl:href="http://www.ietf.org/rfc/rfc3264.txt">RFC3264</link>. The
          negotiation principle is quite simple. At any time, an entity
          generates an offer, with all supported codecs. This offer is sent
          to another entity. Later, the entity that received the offer parses
          this offer, analyzes it, and generates an answer. There is always
          one answer for one offer. The answer depends on offer, it's not
          always the same. 
        </para>
        <para>
          In SIP theory, an offer can be present in either INVITE or 200
          body. If the offer is in INVITE, the answer is in 200, and if the
          offer is in 200, the answer is in ACK body and INVITE body is
          empty. In practice, this former case is extremely rare. SDP
          contains critical information about media streams. It provides the
          IP address and the port on which it whishes to receive RTP packets,
          but it also describes the payload types that it supports. Remember,
          SDP gives media description, not media content. The protocol that
          transports media streams is RTP. This protocol transports encoded
          media with a specific wrapping format, this is the payload type.
          Here is an example SDP session description:
        </para>
        <literallayout><literal>v=0
o=alice 2890844526 2890844526 IN IP4 client.atlanta.example.com
s=-
c=IN IP4 192.0.2.101
t=0 0
m=audio 49172 RTP/AVP 0
a=rtpmap:0 PCMU/8000</literal></literallayout>
        <para>
          Reading this SDP, we can conclude that this entity is listening on
          IP address 192.0.2.101 on port 49172 for RTP PCMU packets (payload
          type 0), sampled at 8000 Hz. Payload types and their corresponding
          codec are given in <link
          xl:href="http://www.ietf.org/rfc/rfc3551.txt">RFC3551</link>. 
        </para>
        <para>
          If we take a look at Peers source code, SDPManager is the place
          where everything is done at SDP level. This class generates offers,
          parses answers to extract useful information (IP address, port,
          payload type), and generates answers based on incoming offers. The
          object employed to describe an SDP body is SessionDescription. A
          SessionDescription can contain several MediaDescriptions. A
          MediaDescription typically corresponds to an audio stream or a
          video stream. A MediaDescription can contain several Codecs. 
        </para>
        <figure>
          <title>SDP objects</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="sdp.svg" width="40mm"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="sdp.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          The combination of IP address, port and Codec is grouped is a
          MediaDestination. This class eases RTP targets description. The
          content of those classes corresponds to <link
          xl:href="http://www.ietf.org/rfc/rfc4566.txt">RFC4566</link>
          parameters description. 
        </para>
      </section>
      <section>
        <title>Media</title>
        <para>
          The main classes of this package are IncomingRtpReader and
          CaptureRtpSender. Actually, IncomingRtpReader is responsible for
          RTP depacketization, media decompression and media playback ; and
          CaptureRtpReader is responsible for microphone capture, media
          encoding and RTP packetization. Thus, CaptureRtpSender has
          references to Capture, Encoder and RtpSender instances. Each of
          this class implements Runnable, and is running in a separate
          Thread. Data is transmitted using pipes (PipedOutputStreams and
          PipedInputStreams) amongst those media manipulation objects.
          Nevertheless, IncomingRtpReader does not use separate threads for
          depacketization and media playback. 
        </para>
        <para>
          The following figure illustrates pipes between Capture, xxxEncoder
          and RtpSender which allow data transmission from microphone capture
          to RTP packet sending. 
        </para>
        <figure>
          <title>Media pipes</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="pipes.svg" width="120mm"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="pipes.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <section>
          <title>Javasound</title>
          <para>
            This media package relies on rtp peers package and javasound.
            Javasound is standard sun javasound API. Thus you can use their
            web pages for more information and <link
            xl:href="http://download.oracle.com/javase/tutorial/sound/TOC.html">tutorials</link>.
            All interaction with javasound API is done in SoundManager.
            Thus, if you want to use another sound API, you can only modify
            this class. Bird view: javasound defines SourceDataLines for
            media playback and TargetDataLine for media capture. A global
            AudioSystem class is there to retrieve all information about
            sound card, etc. AudioDataFormats give description about codec
            and audio bitstream format. The last important aspect of
            javasound is Line. Lines are used for stream control:
            start/stop, etc. Peers captures audio data at 8 kHz,
            using 16 bits samples, one channel (mono), and signed
            little-endian samples. 
          </para>
          <para>
            The use of javasound for media capture and playback is critical.
            Even if it's not the simplest java media API, it has the
            advantage of being tested by sun on each supported platform
            (windows, linux, mac, solaris, etc.). Peers has been tested
            successfully on linux, windows and mac os 10.6. Javasound has
            many drawbacks: few guaranteed features, no standard audio data
            format (frequency, sample size, etc.). But it's already
            integrated in java standard edition API, and it avoids
            third-party libraries with native parts, etc.
          </para>
          <para>
            SoundManager defines two methods to open and close lines on the
            host sound card. Thus, the line used to play sound
            (SourceDataLine) and the line used to capture sound
            (TargetDataLine) are opened one after another, not in parallel.
            Tests have proved that it is more secure to open one line after
            another. Parallel lines opening can create JVM crashes. Once
            opened, those line take and provide data. The data that has to
            be played can simply be provided to SoundManager through
            writeData(...) and the capture sound data can be retrieved
            through readData(...). 
          </para>
        </section>
        <section>
          <title>Media debug</title>
          <para>
            Peers provides an option in its configuration file called
            mediaDebug. This parameter takes a boolean value. If true, almost
            all media data will be written to several files in media/
            directory corresponding to each step in both directions.
            From peers user to remote contact:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                data captured from javasound before encoding =&gt;
                _PCM_SIGNED_8000.0_16_1_le_microphone.output
              </para>
            </listitem>
            <listitem>
              <para>encoder input =&gt; _g711_encoder.input</para>
            </listitem>
            <listitem>
              <para>encoder output =&gt; _g711_encoder.output</para>
            </listitem>
            <listitem>
              <para>rtp sender input =&gt; _rtp_sender.input</para>
            </listitem>
            <listitem>
              <para>
                rtp session output (including rtp header) =&gt;
                _rtp_session.output
              </para>
            </listitem>
          </itemizedlist>
          <para>
            From remote contact to peers user:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                rtp session input (incoming rtp packets received, including
                rtp header) =&gt; _rtp_session.input
              </para>
            </listitem>
            <listitem>
              <para>
                data provided to javasound to really play sound =&gt;
                _PCM_SIGNED_8000.0_16_1_le_speaker.input
              </para>
            </listitem>
          </itemizedlist>
          <para>
            As you can see, decoder input and output are not written to their
            file, this is because this step has not required too much debug.
            All files start with date using the following format:
            yyyy-MM-dd_HH-mm-ss. Remember that this parameter is only
            useful for debug purpose, it slows down media streams very much. 
          </para>
          <para>
            PCM_SIGNED_... give the format of raw data contained in this
            file. Those files can be imported in <link
            xl:href="http://audacity.sourceforge.net/">Audacity</link> using
            File &gt; Import &gt; Raw data and the following parameters:
          </para>
          <itemizedlist>
            <listitem>
              <para>Signed 16 bit PCM</para>
            </listitem>
            <listitem>
              <para>Little-endian</para>
            </listitem>
            <listitem>
              <para>1 Canal</para>
            </listitem>
            <listitem>
              <para>Sample Frequency: 8000 Hz</para>
            </listitem>
          </itemizedlist>
          <para>
            Thus you can see what is being provided to javasound. This may
            help media debugging. 
          </para>
          <figure>
            <title>Importing raw data in Audacity</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="audacity.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
        <section>
          <title>Codecs</title>
          <para>
            Peers codecs have been implemented the most generic way as
            possible. Thus two abstract classes Encoder and Decoder have been
            created. Encoder is a Runnable and Decoder is not. Those
            abstract classes are overloaded by codecs. As PCMU and PCMA are
            supported in peers, each one has it own Encoder and Decoder: 
          </para>
          <figure>
            <title>Codecs implementation</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="media_classes.svg" width="130mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="media_classes.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            Encoder and Decoder classes only define a process(...) method
            that will work on input to generate an output depending on codec
            algorithm. Encoder is started at the beginning of a call and only
            the codec-specific encoding is done in concrete class.
          </para>
        </section>
      </section>
      <section>
        <title>RTP</title>
        <para>
          Peers RTP stack is very simple. The main class of this stack is
          RtpSession. This class handles the packet sending and reception.
          It relies on java 5 ExecutorService to receive packets.
          Nevertheless it does not create a separate thread to send packets,
          it simply sends them on demand using send(RtpPacket) method. As
          other packets, RTP package makes use of a listener to notify the
          reception of an RTP packet. When a packet is received, the raw data
          is parsed using RtpParser class. Thus a new RtpPacket is created
          and provided to the RtpListeners which subscribed to RTP packet
          reception on RtpSession. 
        </para>
        <figure>
          <title>RTP packet flow</title>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="rtp.svg" width="130mm"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="rtp.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          An RtpPacket contains standard RTP headers and data (ssrc,
          sequenceNumber, payloadType, etc.). Peers RTP stack is based on
          <link xl:href="http://www.ietf.org/rfc/rfc3550.txt">RFC3550</link>.
          Before it can be used, an RtpSession has to be started using
          start() method. Later it can be stopped using stop() method. An
          RtpSession uses an initial remote IP address and a port number to
          send first RTP packets before any RTP packet has been received from
          remote RTP party. Once a packet has been received, if the IP
          address or the port from which the packet is coming differs from
          the previous ones, the remote IP address and port are updated with
          latest ones. This enables NAT traversal in a few cases. Thus
          peers RTP stack support symmetric RTP. 
        </para>
      </section>
      <section>
        <title>GUI</title>
        <para>
          Last but not least, graphical user interface. Peers is based on
          swing for gui management. Once more, swing is already integrated in
          sun JRE. It's light, efficient and uses staight-forward development
          methods. Peers uses OS native look and feel instead of sun's metal
          look and feel. OS look and feel will probably be evolving faster
          than metal look and feel and OS integration is thus improved. 
        </para>
        <para>
          GUI is based on a class which manages all events coming from SIP
          layer and from user and dispatches events amongst GUI components.
          This class is EventManager. This class receives invocations from
          sip layer using its SipListener interface. It then dispatches
          events to the appropriated frames. Several frames are implemented
          in gui (from the most important one to the less important one):
        </para>
        <itemizedlist>
          <listitem>
            <para>MainFrame</para>
          </listitem>
          <listitem>
            <para>CallFrame</para>
          </listitem>
          <listitem>
            <para>AccountFrame</para>
          </listitem>
          <listitem>
            <para>AboutFrame</para>
          </listitem>
        </itemizedlist>
        <para>
          Some of those frames have been designed using <link
          xl:href="http://netbeans.org/">netbeans</link> with an empty
          project and then integrated in peers main source code, implementing
          only triggers on appropriated events (typically button clicks).
          Thus, graphical design has not been too harsh. 
        </para>
        <section>
          <title>MainFrame</title>
          <para>
            MainFrame is actually the class that contains the main() method
            of peers, so this is the first class to be instanciated.
            MainFrame creates and references EventManager. Then
            EventManager creates and manages other frames and their
            corresponding events. 
          </para>
          <para>
            Here is a screenshot of MainFrame: 
          </para>
          <figure>
            <title>MainFrame in action</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="main_frame_registered.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
        <section>
          <title>EventManager</title>
          <figure>
            <title>GUI event manager</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="gui-eventmanager.svg" width="90mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="gui-eventmanager.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            EventManager is listening to frames through listeners interfaces:
            MainFrameListener, CallFrameListener. EventManager also
            implements ActionListener to receive events from MainFrame
            JMenu. Thus when user is clicking on Edit &gt; Account, the
            corresponding event reaches EventManager and EventManager
            eventually instanciates a new AccountFrame to enable user
            configure sip account. 
          </para>
        </section>
        <section>
          <title>CallFrame</title>
          <para>
            When user places or receives a new call, a new CallFrame is
            created and displayed to user. Here is an example after callee
            pickup: 
          </para>
          <figure>
            <title>CallFrame in action</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="call_frame.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            Peers defines a state machine to maintain the state of this
            window. This state machine uses the classical model employed in
            peers (one class per state and a mother class for all states).
            The same state machine is employed for calls originating from
            peers user and terminating towards peers user. Here is this state
            machine: 
          </para>
          <figure>
            <title>CallFrame state machine</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="call_frame_state_machine.svg" width="170mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="call_frame_state_machine.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            The keypad displayed in CallFrame has its own Keypad class to
            improve CallFrame readability and share this simple component
            from core CallFrame code. This Keypad component is visible in
            previous CallFrame screenshot. 
          </para>
        </section>
        <section>
          <title>AccountFrame</title>
          <para>
            This frame enables peers user to configure his or her sip account
            with a minimal interface: 
          </para>
          <figure>
            <title>AccountFrame in action</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="account_frame_registered.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            This class also displays the registration state of the
            corresponding account. Actually, this registration state is also
            displayed in MainFrame to let user know that his or her account
            is registered on regular peers startup. As this "registration
            state" component had to be displayed on several frames, a
            specific component has been written in Registration class. This
            class also makes use of a state machine, because of asynchronous
            registration events coming from sip stack. 
          </para>
          <figure>
            <title>GUI Registration state machine</title>
            <mediaobject>
              <imageobject role="fo">
                <imagedata fileref="registration_state_machine.svg" width="150mm"/>
              </imageobject>
              <imageobject role="html">
                <imagedata fileref="registration_state_machine.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
        <section>
          <title>AboutFrame</title>
          <para>
            AboutFrame is not that interesting, it's just useful to display
            license to user. 
          </para>
        </section>
      </section>
    </section>
  </chapter>
</book>
